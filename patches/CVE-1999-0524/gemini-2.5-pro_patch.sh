```bash
#!/bin/bash

#==============================================================================
# SCRIPT METADATA
#==============================================================================
# Script Name: remediate_cve-1999-0524.sh
# Description: This script remediates CVE-1999-0524 (ICMP Timestamp Reply Information Disclosure)
#              by disabling ICMP timestamp support through kernel parameters and
#              firewall rules.
# Author: Senior Security Engineer
# Date: 2023-10-27
# Version: 1.0
# CVEs Addressed: CVE-1999-0524
#
# Remediation Strategy:
# 1. Sysctl Hardening: Set net.ipv4.icmp_echo_ignore_all = 1 to ignore all ICMP echo requests.
#    While primarily for echo, this contributes to general ICMP stealth.
# 2. Firewall Rules (UFW): Block incoming ICMP Type 13 (Timestamp Request) and
#    outgoing ICMP Type 14 (Timestamp Reply) using UFW.
#
# Idempotency: The script checks if the remediation is already applied before
#              making changes and exits gracefully if so.
# Auditability: Logs all actions to a file with timestamps.
# Safety: Creates backups of modified configuration files.
# Rollback: Provides clear instructions for manual rollback.
# Exit Codes:
#   0 - Success (vulnerability remediated or already patched)
#   1 - Already patched
#   2 - Error during execution or environment check
#==============================================================================

#==============================================================================
# CONFIGURATION
#==============================================================================
LOG_FILE="/var/log/vulnerability_remediation_$(date +%Y%m%d_%H%M%S).log"
BACKUP_DIR="/var/backups/vulnerability_remediation/cve-1999-0524"
TIMESTAMP=$(date +"%Y%m%d%H%M%S")

#==============================================================================
# GLOBAL VARIABLES AND CONSTANTS
#==============================================================================
SYSCTL_CONF_FILE="/etc/sysctl.conf"
SYSCTL_PARAM="net.ipv4.icmp_echo_ignore_all"
SYSCTL_VALUE="1"
UFW_INSTALLED=false # Flag to track if UFW is installed

#==============================================================================
# SCRIPT BEHAVIOR AND ERROR HANDLING
#==============================================================================

# Exit immediately if a command exits with a non-zero status.
set -e
# Exit if any command in a pipeline fails.
set -o pipefail
# Exit if an unset variable is used.
set -u

#==============================================================================
# LOGGING FUNCTIONS
#==============================================================================

# Log an informational message
log_info() {
    echo "$(date +"%Y-%m-%d %H:%M:%S") [INFO] $1" | tee -a "${LOG_FILE}"
}

# Log a warning message
log_warn() {
    echo "$(date +"%Y-%m-%d %H:%M:%S") [WARN] $1" | tee -a "${LOG_FILE}" >&2
}

# Log an error message and exit
log_error() {
    echo "$(date +"%Y-%m-%d %H:%M:%S") [ERROR] $1" | tee -a "${LOG_FILE}" >&2
    exit 2
}

#==============================================================================
# TRAP HANDLERS
#==============================================================================

# Cleanup function to be called on script exit or error
cleanup() {
    local exit_code=$?
    if [ "${exit_code}" -ne 0 ] && [ "${exit_code}" -ne 1 ]; then # 0=success, 1=already patched, 2=error
        log_error "Script failed with exit code ${exit_code}. Please review the log file: ${LOG_FILE}"
        log_info "Attempting to clean up any temporary files or partial changes..."
        # Add any specific cleanup actions here if needed, e.g., restoring temp files
    fi
    log_info "Script finished."
}

trap cleanup EXIT

#==============================================================================
# HELPER FUNCTIONS
#==============================================================================

# Check for root privileges
check_root() {
    if [[ "$(id -u)" -ne 0 ]]; then
        log_error "This script must be run as root. Please use 'sudo' or log in as root."
    fi
    log_info "Root privileges confirmed."
}

# Create a timestamped backup of a file
backup_file() {
    local file_path="$1"
    if [ ! -f "${file_path}" ]; then
        log_warn "File to backup does not exist: ${file_path}"
        return 0
    fi
    mkdir -p "${BACKUP_DIR}" || log_error "Failed to create backup directory: ${BACKUP_DIR}"
    cp -p "${file_path}" "${BACKUP_DIR}/$(basename "${file_path}")_${TIMESTAMP}" || log_error "Failed to backup ${file_path}"
    log_info "Backed up ${file_path} to ${BACKUP_DIR}/$(basename "${file_path}")_${TIMESTAMP}"
}

#==============================================================================
# ENVIRONMENT VALIDATION
#==============================================================================

# Validate the computational environment
check_environment() {
    log_info "Starting environment validation..."

    # Check OS
    if [[ "$(uname -s)" != "Linux" ]]; then
        log_error "Unsupported operating system. This script is designed for Linux systems only."
    fi
    log_info "OS is Linux (uname -s: $(uname -s))."

    # Check for `sysctl` command
    if ! command -v sysctl &> /dev/null; then
        log_error "'sysctl' command not found. It is required for kernel parameter modification."
    fi
    log_info "'sysctl' command found."

    # Check for `ufw` command (preferred firewall for Pop!_OS/Ubuntu)
    if ! command -v ufw &> /dev/null; then
        log_warn "'ufw' command not found. UFW is recommended for firewall-based remediation on Pop!_OS/Ubuntu. Please consider installing it with 'sudo apt install ufw'."
        UFW_INSTALLED=false
    else
        log_info "'ufw' command found."
        UFW_INSTALLED=true
    fi

    # Check for `apt` package manager
    if ! command -v apt &> /dev/null; then
        log_error "'apt' package manager not found. This script assumes an APT-based system (Pop!_OS/Ubuntu)."
    fi
    log_info "'apt' package manager found."

    log_info "Environment validation complete."
}

#==============================================================================
# VULNERABILITY DETECTION & IDEMPOTENCY CHECKS
#==============================================================================

# Check if the sysctl fix is already applied
is_sysctl_patched() {
    # Check if the parameter is actively set to the desired value
    if sysctl -n "${SYSCTL_PARAM}" &>/dev/null && [[ "$(sysctl -n "${SYSCTL_PARAM}")" -eq "${SYSCTL_VALUE}" ]]; then
        log_info "Sysctl parameter '${SYSCTL_PARAM}=${SYSCTL_VALUE}' is already active."
        # Also check if it's persistently configured in sysctl.conf
        if grep -qP "^\s*${SYSCTL_PARAM}\s*=\s*${SYSCTL_VALUE}" "${SYSCTL_CONF_FILE}"; then
            log_info "Sysctl parameter '${SYSCTL_PARAM}=${SYSCTL_VALUE}' is already configured in ${SYSCTL_CONF_FILE}."
            return 0 # Patched
        else
            log_warn "Sysctl parameter '${SYSCTL_PARAM}=${SYSCTL_VALUE}' is active but not found in ${SYSCTL_CONF_FILE}. Script will ensure persistence."
            return 1 # Not persistently patched
        fi
    else
        log_info "Sysctl parameter '${SYSCTL_PARAM}=${SYSCTL_VALUE}' is not active or not set."
        return 1 # Not patched
    fi
}

# Check if the UFW fix is already applied
is_ufw_patched() {
    if ! "${UFW_INSTALLED}"; then
        log_warn "UFW is not installed, skipping UFW-based idempotency check."
        return 1 # Not patched (as UFW part is not present)
    fi

    if ! ufw status | grep -q "Status: active"; then
        log_warn "UFW is not active, UFW rules are not enforced. UFW part is not considered patched."
        return 1 # Not patched
    fi

    local rules_output
    rules_output=$(ufw status verbose)

    # Check for incoming ICMP Type 13 (Timestamp Request) deny rule
    if ! echo "${rules_output}" | grep -qP "DENY IN.*ICMP.*type 13"; then
        log_info "UFW rule to deny incoming ICMP type 13 (timestamp-request) not found."
        return 1
    fi

    # Check for outgoing ICMP Type 14 (Timestamp Reply) deny rule
    if ! echo "${rules_output}" | grep -qP "DENY OUT.*ICMP.*type 14"; then
        log_info "UFW rule to deny outgoing ICMP type 14 (timestamp-reply) not found."
        return 1
    fi

    log_info "UFW rules for blocking ICMP Type 13 (timestamp-request) and Type 14 (timestamp-reply) are already in place and UFW is active."
    return 0 # Patched
}

# Check if the overall vulnerability is already remediated
is_vulnerability_remediated() {
    local sysctl_status
    local ufw_status

    is_sysctl_patched
    sysctl_status=$?

    # Only check UFW status if UFW is installed
    if "${UFW_INSTALLED}"; then
        is_ufw_patched
        ufw_status=$?
    else
        log_warn "UFW is not installed. Considering the UFW part as not fully remediated by the script's intended method."
        ufw_status=1 # Treat as not patched for UFW part if not installed
    fi

    # If both sysctl and ufw parts are patched, then the vulnerability is remediated
    if [[ "${sysctl_status}" -eq 0 ]] && [[ "${ufw_status}" -eq 0 ]]; then
        log_info "Vulnerability appears to be already remediated based on current configurations."
        return 0
    else
        log_info "Vulnerability remediation is incomplete or not applied."
        return 1
    fi
}

#==============================================================================
# REMEDIATION FUNCTIONS
#==============================================================================

# Apply sysctl hardening
apply_sysctl_fix() {
    log_info "Applying sysctl fix for '${SYSCTL_PARAM}'..."

    backup_file "${SYSCTL_CONF_FILE}"

    # Remove existing lines of the parameter and add the desired one
    if grep -qP "^\s*${SYSCTL_PARAM}" "${SYSCTL_CONF_FILE}"; then
        log_info "Updating existing '${SYSCTL_PARAM}' entry in ${SYSCTL_CONF_FILE}."
        sed -i "/^\s*${SYSCTL_PARAM}/c\\${SYSCTL_PARAM} = ${SYSCTL_VALUE}" "${SYSCTL_CONF_FILE}" || log_error "Failed to update ${SYSCTL_CONF_FILE}."
    else
        log_info "Adding '${SYSCTL_PARAM}=${SYSCTL_VALUE}' to ${SYSCTL_CONF_FILE}."
        # Add a newline and comment for readability before adding the parameter
        echo "" | tee -a "${SYSCTL_CONF_FILE}" >/dev/null
        echo "# Remediation for CVE-1999-0524: Disable ICMP echo replies for general stealth" | tee -a "${SYSCTL_CONF_FILE}" >/dev/null
        echo "${SYSCTL_PARAM} = ${SYSCTL_VALUE}" | tee -a "${SYSCTL_CONF_FILE}" >/dev/null || log_error "Failed to add to ${SYSCTL_CONF_FILE}."
    fi

    # Apply the changes immediately
    sysctl -p || log_error "Failed to apply sysctl changes with 'sysctl -p'."
    log_info "Sysctl fix for '${SYSCTL_PARAM}' applied successfully and made persistent."

    # Verify active setting
    if [[ "$(sysctl -n "${SYSCTL_PARAM}")" -ne "${SYSCTL_VALUE}" ]]; then
        log_error "Verification failed: '${SYSCTL_PARAM}' is not set to '${SYSCTL_VALUE}' after applying sysctl changes."
    fi
}

# Apply UFW firewall rules
apply_ufw_fix() {
    if ! "${UFW_INSTALLED}"; then
        log_warn "UFW is not installed. Skipping UFW-based firewall remediation. Please install UFW with 'sudo apt install ufw' and re-run for full remediation."
        return 0
    fi

    log_info "Applying UFW firewall rules to block ICMP Type 13 and 14..."

    # Backup current UFW rules before modification
    mkdir -p "${BACKUP_DIR}" || log_error "Failed to create backup directory: ${BACKUP_DIR}"
    if ufw status raw &> /dev/null; then
        ufw status raw > "${BACKUP_DIR}/ufw_rules_${TIMESTAMP}.txt" || log_error "Failed to backup UFW rules."
        log_info "Backed up UFW rules to ${BACKUP_DIR}/ufw_rules_${TIMESTAMP}.txt"
    else
        log_warn "Could not get raw UFW status to backup. UFW might not be fully configured or active."
    fi

    local ufw_was_inactive=false
    # Enable UFW if not active
    if ! ufw status | grep -q "Status: active"; then
        ufw_was_inactive=true
        log_warn "UFW is not active. Activating UFW now. This might impact existing network connections if not properly configured."
        log_info "It's highly recommended to explicitly allow necessary services (e.g., SSH) before enabling UFW if not already configured."
        ufw --force enable || log_error "Failed to enable UFW."
        log_info "UFW activated. Default policy for incoming is 'deny'."
    fi

    # Add rules to deny incoming ICMP Type 13 (Timestamp Request)
    if ! ufw status verbose | grep -qP "DENY IN.*ICMP.*type 13"; then
        log_info "Adding UFW rule to deny incoming ICMP type 13 (timestamp-request)."
        ufw deny in icmp type timestamp-request || log_error "Failed to add UFW rule for incoming ICMP type 13."
        log_info "UFW rule added: deny incoming ICMP type 13 (timestamp-request)."
    else
        log_info "UFW rule for incoming ICMP type 13 (timestamp-request) already exists."
    fi

    # Add rules to deny outgoing ICMP Type 14 (Timestamp Reply)
    if ! ufw status verbose | grep -qP "DENY OUT.*ICMP.*type 14"; then
        log_info "Adding UFW rule to deny outgoing ICMP type 14 (timestamp-reply)."
        ufw deny out icmp type timestamp-reply || log_error "Failed to add UFW rule for outgoing ICMP type 14."
        log_info "UFW rule added: deny outgoing ICMP type 14 (timestamp-reply)."
    else
        log_info "UFW rule for outgoing ICMP type 14 (timestamp-reply) already exists."
    fi

    if "${ufw_was_inactive}"; then
        log_info "UFW was activated by this script. Please review your firewall rules to ensure desired connectivity."
    fi

    log_info "UFW firewall rules applied successfully."
}

#==============================================================================
# VERIFICATION
#==============================================================================

# Verify that the fixes have been applied successfully
verify_remediation() {
    log_info "Verifying remediation steps..."

    local sysctl_verified=false
    local ufw_verified=false

    # Verify sysctl setting
    if sysctl -n "${SYSCTL_PARAM}" &>/dev/null && [[ "$(sysctl -n "${SYSCTL_PARAM}")" -eq "${SYSCTL_VALUE}" ]]; then
        log_info "Verification: Sysctl parameter '${SYSCTL_PARAM}' is actively set to '${SYSCTL_VALUE}'."
        if grep -qP "^\s*${SYSCTL_PARAM}\s*=\s*${SYSCTL_VALUE}" "${SYSCTL_CONF_FILE}"; then
            log_info "Verification: Sysctl parameter '${SYSCTL_PARAM}' is persistently configured in ${SYSCTL_CONF_FILE}."
            sysctl_verified=true
        else
            log_error "Verification failed: '${SYSCTL_PARAM}' is active but not persistent in ${SYSCTL_CONF_FILE}."
        fi
    else
        log_error "Verification failed: Sysctl parameter '${SYSCTL_PARAM}' is not actively set to '${SYSCTL_VALUE}'."
    fi

    # Verify UFW rules (only if UFW is installed and active)
    if "${UFW_INSTALLED}"; then
        if ufw status | grep -q "Status: active"; then
            local rules_output
            rules_output=$(ufw status verbose)
            if echo "${rules_output}" | grep -qP "DENY IN.*ICMP.*type 13" && \
               echo "${rules_output}" | grep -qP "DENY OUT.*ICMP.*type 14"; then
                log_info "Verification: UFW rules for blocking ICMP Type 13 (timestamp-request) and Type 14 (timestamp-reply) are present and UFW is active."
                ufw_verified=true
            else
                log_error "Verification failed: UFW is active, but required ICMP deny rules for Type 13/14 are missing."
            fi
        else
            log_error "Verification failed: UFW is not active, firewall rules are not enforced for Type 13/14."
        fi
    else
        log_warn "UFW is not installed, skipping UFW specific rule verification. Sysctl part is considered the primary remediation for this host."
        ufw_verified=true # If UFW not installed, its part of remediation is considered 'verified' in that context
    fi

    if "${sysctl_verified}" && "${ufw_verified}"; then
        log_info "ALL REMEDIATION STEPS SUCCESSFULLY VERIFIED."
        log_info "---"
        log_info "To definitively confirm the vulnerability is mitigated, perform an external scan:"
        log_info "From another host, run: nmap -Pn --script icmp-timestamp <TARGET_IP>"
        log_info "The Nmap output should indicate that no timestamp reply was received."
        log_info "---"
        return 0
    else
        log_error "One or more remediation steps could not be verified. Please check the log file for details."
    fi
}

#==============================================================================
# ROLLBACK INSTRUCTIONS
#==============================================================================

print_rollback_instructions() {
    log_info "--- ROLLBACK INSTRUCTIONS ---"
    log_info "If you need to revert the changes made by this script:"
    log_info "1. For Sysctl changes:"
    log_info "   a. Restore /etc/sysctl.conf from backup: 'sudo cp ${BACKUP_DIR}/sysctl.conf_${TIMESTAMP} ${SYSCTL_CONF_FILE}'"
    log_info "   b. Apply the old settings: 'sudo sysctl -p'"
    log_info "2. For UFW changes (if UFW was installed and enabled by the script):"
    log_info "   a. To remove the specific ICMP rules, you'll need their rule numbers. Run 'sudo ufw status numbered' and look for rules related to 'deny in icmp type 13' and 'deny out icmp type 14'. Then delete them using 'sudo ufw delete <rule_number>'."
    log_info "      Example (replace X, Y with actual rule numbers): 'sudo ufw delete X' and 'sudo ufw delete Y'"
    log_info "   b. If UFW was enabled by this script and you wish to disable it completely (use with caution): 'sudo ufw disable'"
    log_info "   c. Alternatively, you can attempt to restore from the UFW raw rules backup (advanced, requires manual iptables loading or a full UFW reset): 'sudo iptables-restore < ${BACKUP_DIR}/ufw_rules_${TIMESTAMP}.txt'"
    log_info "Make sure to reboot or reload services if needed after rollback to ensure all changes are undone."
    log_info "---------------------------"
}

#==============================================================================
# MAIN EXECUTION
#==============================================================================

main() {
    log_info "Starting remediation script for CVE-1999-0524."
    log_info "Log file: ${LOG_FILE}"

    check_root
    check_environment

    if is_vulnerability_remediated; then
        log_info "Vulnerability CVE-1999-0524 is already remediated. No changes made."
        print_rollback_instructions
        exit 1 # Exit code for already patched
    fi

    log_info "Vulnerability detected. Applying remediation steps."

    apply_sysctl_fix
    apply_ufw_fix

    log_info "Remediation steps applied. Proceeding to verification."
    verify_remediation

    print_rollback_instructions
    log_info "Script execution completed successfully."
    exit 0 # Success
}

main "$@"
```