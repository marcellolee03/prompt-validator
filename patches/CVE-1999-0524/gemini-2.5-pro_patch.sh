```bash
#!/bin/bash
#
# REMEDIATION SCRIPT FOR CVE-1999-0524 (ICMP Timestamp Reply)
#
# Description:
# This script remediates the vulnerability where a system responds to ICMP
# timestamp requests (Type 13), which can disclose system time and confirm
# the host is alive. The script hardens the system by adding a firewall rule
# to drop incoming ICMP timestamp requests.
#
# It is designed to be:
#   - Safe: Backs up configuration files before modification.
#   - Idempotent: Can be run multiple times without causing harm. If the
#     system is already patched, it will detect this and exit gracefully.
#   - Auditable: Logs all actions to a log file and standard output.
#   - Robust: Prefers high-level firewall managers like UFW if available,
#     falling back to iptables. Includes comprehensive error handling.
#
# Author: Senior Security Engineer
# Version: 1.1
# Last Modified: 2025-01-22

# --- Best Practices and Error Handling ---
# Exit immediately if a command exits with a non-zero status.
set -o errexit
# Treat unset variables as an error when substituting.
set -o nounset
# Pipelines return the exit status of the last command to exit with a
# non-zero status, or zero if all commands exit successfully.
set -o pipefail

# --- Script Constants ---
readonly SCRIPT_NAME="$(basename "$0")"
readonly LOG_FILE="/var/log/remediation_$(date +%Y%m%d).log"
readonly TIMESTAMP="$(date --iso-8601=seconds)"
readonly BACKUP_TIMESTAMP="$(date +%Y%m%d_%H%M%S)"

# --- Exit Codes ---
# 0: Success
# 1: Already remediated
# 2: Remediation failed
# 3: Prerequisite missing / Unsupported environment
# 4: Script not run as root

# --- Logging and Output Functions ---

# Function to log messages to both stdout and a log file.
# Usage: log_msg "INFO" "This is an informational message."
log_msg() {
    local level="$1"
    local message="$2"
    echo "[$TIMESTAMP] [$level] - $message" | tee -a "$LOG_FILE"
}

# --- Cleanup Function ---

# This function is called on script exit or error to perform cleanup.
cleanup() {
    log_msg "INFO" "Script finished."
}
trap cleanup EXIT

# --- Core Logic Functions ---

# Checks if the script is run with root privileges.
check_root() {
    if [[ "${EUID}" -ne 0 ]]; then
        log_msg "ERROR" "This script must be run as root. Aborting."
        exit 4
    fi
}

# Determines the active firewall manager (ufw or iptables).
# Returns "ufw" or "iptables". Exits if none are suitable.
detect_firewall_manager() {
    if command -v ufw &>/dev/null && ufw status | grep -q "Status: active"; then
        echo "ufw"
    elif command -v iptables &>/dev/null; then
        echo "iptables"
    else
        log_msg "ERROR" "No suitable firewall manager (ufw or iptables) found. Aborting."
        exit 3
    fi
}

# Checks if the remediation is already in place.
# Returns 0 if remediated, 1 if not.
is_remediated() {
    local manager="$1"
    local ufw_rules_file="/etc/ufw/before.rules"
    # Rule fragment to search for, matching ICMP type 13 (timestamp-request)
    local rule_fragment="-p icmp --icmp-type 13 -j DROP"

    log_msg "INFO" "Checking if system is already remediated..."

    if [[ "$manager" == "ufw" ]]; then
        if [[ -f "$ufw_rules_file" ]] && grep -q -- "$rule_fragment" "$ufw_rules_file"; then
            log_msg "INFO" "UFW rule to block ICMP timestamp requests already exists in $ufw_rules_file."
            return 0
        fi
    elif [[ "$manager" == "iptables" ]]; then
        # Use 'iptables-save' for a reliable check of all rules, not just 'iptables -S'
        if iptables-save | grep -q -- "$rule_fragment"; then
            log_msg "INFO" "iptables rule to block ICMP timestamp requests already exists."
            return 0
        fi
    fi

    log_msg "INFO" "System is not yet remediated."
    return 1
}

# Applies the fix using UFW (Uncomplicated Firewall).
remediate_with_ufw() {
    log_msg "INFO" "Applying remediation using UFW..."
    local ufw_rules_file="/etc/ufw/before.rules"
    local backup_file="${ufw_rules_file}.bak.${BACKUP_TIMESTAMP}"
    local rule_to_add="-A ufw-before-input -p icmp --icmp-type 13 -j DROP"

    if [[ ! -f "$ufw_rules_file" ]]; then
        log_msg "ERROR" "UFW rules file not found at $ufw_rules_file. Aborting."
        exit 3
    fi

    # 1. Create a backup
    log_msg "INFO" "Backing up '$ufw_rules_file' to '$backup_file'."
    cp "$ufw_rules_file" "$backup_file"

    # 2. Add the rule before the final 'COMMIT' line in the file
    if ! sed -i "/^COMMIT/i $rule_to_add" "$ufw_rules_file"; then
        log_msg "ERROR" "Failed to insert rule into '$ufw_rules_file'. Restoring from backup."
        cp "$backup_file" "$ufw_rules_file"
        exit 2
    fi
    log_msg "INFO" "Successfully added rule to '$ufw_rules_file'."

    # 3. Reload UFW to apply changes
    log_msg "INFO" "Reloading UFW to apply the new rule..."
    if ! ufw reload > /dev/null; then
        log_msg "ERROR" "Failed to reload UFW. A syntax error may have been introduced."
        log_msg "ERROR" "Attempting to restore from backup '$backup_file'."
        cp "$backup_file" "$ufw_rules_file"
        log_msg "ERROR" "Restored. Now attempting to reload UFW again."
        ufw reload > /dev/null || log_msg "ERROR" "Could not reload UFW after restore. Manual intervention required."
        exit 2
    fi
    log_msg "INFO" "UFW reloaded successfully."
}

# Applies the fix using iptables and ensures persistence.
remediate_with_iptables() {
    log_msg "INFO" "Applying remediation using iptables..."

    # 1. Check for iptables-persistent package
    if ! dpkg-query -W -f='${Status}' iptables-persistent &>/dev/null | grep -q "ok installed"; then
        log_msg "ERROR" "The 'iptables-persistent' package is required to make rules permanent."
        log_msg "ERROR" "Please install it first (e.g., 'sudo apt-get install iptables-persistent') and re-run this script. Aborting."
        exit 3
    fi

    # 2. Add the rule to the top of the INPUT chain to ensure it's processed first
    log_msg "INFO" "Adding iptables rule to drop ICMP type 13 (timestamp-request)."
    if ! iptables -I INPUT 1 -p icmp --icmp-type 13 -j DROP; then
        log_msg "ERROR" "Failed to insert iptables rule. Aborting."
        exit 2
    fi
    log_msg "INFO" "Rule added successfully to the live ruleset."

    # 3. Save the rules to make them persistent
    log_msg "INFO" "Saving rules to make them persistent on reboot..."
    if ! iptables-save > /etc/iptables/rules.v4; then
        log_msg "ERROR" "Failed to save iptables rules. The rule will be lost on reboot."
        log_msg "INFO" "Attempting to remove the transient rule."
        iptables -D INPUT -p icmp --icmp-type 13 -j DROP || log_msg "WARN" "Could not remove transient rule."
        exit 2
    fi
    log_msg "INFO" "iptables rules saved successfully."
}


# --- Main Execution ---

main() {
    # Ensure log file exists and has correct permissions
    touch "$LOG_FILE"
    chmod 640 "$LOG_FILE"

    log_msg "INFO" "Starting CVE-1999-0524 remediation script."

    check_root

    local firewall_manager
    firewall_manager=$(detect_firewall_manager)
    log_msg "INFO" "Detected active firewall manager: $firewall_manager."

    if is_remediated "$firewall_manager"; then
        log_msg "INFO" "System is already protected against CVE-1999-0524. No action taken."
        exit 1
    fi

    if [[ "$firewall_manager" == "ufw" ]]; then
        remediate_with_ufw
    elif [[ "$firewall_manager" == "iptables" ]]; then
        remediate_with_iptables
    fi

    log_msg "INFO" "Remediation applied. Performing final verification..."
    if is_remediated "$firewall_manager"; then
        log_msg "INFO" "VERIFICATION SUCCESS: The remediation rule is active."
        log_msg "INFO" "System is now protected against CVE-1999-0524."
        exit 0
    else
        log_msg "ERROR" "VERIFICATION FAILED: The remediation rule could not be confirmed."
        log_msg "ERROR" "Manual investigation is required. Check firewall configuration and logs."
        if [[ "$firewall_manager" == "ufw" ]]; then
            log_msg "ERROR" "To revert, restore '/etc/ufw/before.rules' from the backup created earlier."
        else
            log_msg "ERROR" "To revert, run 'iptables -D INPUT -p icmp --icmp-type 13 -j DROP' and re-save rules with 'iptables-save > /etc/iptables/rules.v4'."
        fi
        exit 2
    fi
}

# Execute the main function with all script arguments
main "$@"
```